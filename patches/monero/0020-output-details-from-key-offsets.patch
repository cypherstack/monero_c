diff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp
index bb76efcda..173ea9990 100644
--- a/src/wallet/wallet2.cpp
+++ b/src/wallet/wallet2.cpp
@@ -15339,6 +15339,59 @@ size_t wallet2::import_outputs_from_str(const std::string &outputs_st)
   return imported_outputs;
 }
 //----------------------------------------------------------------------------------------------------
+struct output_details
+{
+  uint64_t absolute_offset;      // Absolute global output index.
+  uint64_t amount;               // Amount associated with the output.
+  crypto::public_key public_key; // Public key of the output.
+  crypto::hash txid;             // Transaction ID from which the output originates.
+  bool found;                    // Indicates if the output was found.
+};
+
+std::vector<wallet2::output_details> wallet2::get_output_details_from_key_offsets(const std::vector<uint64_t>& key_offsets) const
+{
+  // Convert relative offsets to absolute.
+  std::vector<uint64_t> absolute_offsets = cryptonote::relative_output_offsets_to_absolute(key_offsets);
+
+  // Prepare the request to the daemon.
+  cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::request req;
+  cryptonote::COMMAND_RPC_GET_OUTPUTS_BIN::response res;
+
+  req.outputs.resize(absolute_offsets.size());
+  for (size_t i = 0; i < absolute_offsets.size(); i)
+  {
+    req.outputs[i].amount = 0; // Use amount = 0 for RingCT outputs.
+    req.outputs[i].index = absolute_offsets[i];
+  }
+  req.get_txid = true; // Request the transaction IDs.
+
+  // Call the daemon's get_outs method.
+  bool r;
+  {
+    boost::lock_guard<boost::mutex> lock(m_daemon_rpc_mutex);
+    r = epee::net_utils::invoke_http_bin("/get_outs.bin", req, res, m_http_client, rpc_timeout);
+  }
+  THROW_ON_RPC_RESPONSE_ERROR_GENERIC(r, {}, res, "/get_outs.bin");
+
+  // Process the outputs.
+  std::vector<output_details> outputs;
+  outputs.reserve(res.outs.size());
+
+  for (size_t i = 0; i < res.outs.size(); i)
+  {
+    const auto& out = res.outs[i];
+    output_details detail;
+    detail.absolute_offset = absolute_offsets[i];
+    detail.amount = out.amount;
+    detail.public_key = out.key;
+    detail.txid = out.txid;
+    detail.found = true;
+    outputs.push_back(detail);
+  }
+
+  return outputs;
+}
+//----------------------------------------------------------------------------------------------------
 crypto::public_key wallet2::get_multisig_signer_public_key() const
 {
   CHECK_AND_ASSERT_THROW_MES(m_multisig, "Wallet is not multisig");
diff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h
index bc16d528c..4283e63be 100644
--- a/src/wallet/wallet2.h
+++ b/src/wallet/wallet2.h
@@ -1663,6 +1663,16 @@ private:
     void process_pool_state(const std::vector<std::tuple<cryptonote::transaction, crypto::hash, bool>> &txs);
     void remove_obsolete_pool_txs(const std::vector<crypto::hash> &tx_hashes, bool remove_if_found);
 
+    struct output_details
+    {
+      uint64_t absolute_offset;      // Absolute global output index.
+      uint64_t amount;               // Amount associated with the output.
+      crypto::public_key public_key; // Public key of the output.
+      crypto::hash txid;             // Transaction ID from which the output originates.
+      bool found;                    // Indicates if the output was found.
+    };
+    std::vector<output_details> get_output_details_from_key_offsets(const std::vector<uint64_t> &key_offsets) const;
+
     std::string encrypt(const char *plaintext, size_t len, const crypto::secret_key &skey, bool authenticated = true) const;
     std::string encrypt(const epee::span<char> &span, const crypto::secret_key &skey, bool authenticated = true) const;
     std::string encrypt(const std::string &plaintext, const crypto::secret_key &skey, bool authenticated = true) const;
